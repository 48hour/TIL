[Final Exam](#final-exam)

[1] 데이터베이스 개념 및 특징
=============================

## 데이터베이스 개념

- 여러 사람이 공용으로 사용하기 위해 통합하고 저장한 운영 데이터의 집합

1. 통합된 데이터 (integrated data)
> 중복최소화   
2. 저장된 데이터 (stored data)
> 컴퓨터 저장 장치에 저장
3. 운영 데이터 (operational data)
> 조직의 목적을 위해 사용된 데이터
4. 공용 데이터 (shared data)

## 데이터 베이스 특징

1. 실시간 접근성 (real time accessibility)
> 데이터베이스는 실시간으로 서비스 된다.
2. 계속적인 변화 (continuous change)
> 실시간으로 갱신된다.
3. 동시 공유 (concurrent sharing)
> 데이터베이스는 서로 다른 업무 또는 여러 사용자에게 동시에 공유된다.
4. 내용에 따른 참조 (reference by content)
> 데이터베이스에 저장된 데이터는 데이터의 물리적인 위치가 아니라 데이터 값에 따라 참조된다.

## 데이터베이스 시스템의 구성

- 각 조직에서 사용하던 데이터를 통합하고 공유할 때 생기는 장점을 이용하는 시스템

구성 : 데이터베이스 관리 시스템(DBMS), 데이터베이스, 데이터 모델   
> 데이터베이스 : 실제 데이터가 물리적으로 저장되는 곳   
> 데이터베이스 관리시스템(DBMS) : 데이터를 관리하는 S/W 시스템   
> 데이터 모델 : 데이터베이스에 저장될 정보의 구조 정의에 사용되는 논리적 개념   

      
[2] 파일시스템과 DBMS 비교
======================

## 파일 시스템 (file system)

- 데이터를 파일로 관리할 수 있도록 파일을 생성, 삭제, 수정, 검색하는 기능을 제공함

- 응용 프로그램 별로 필요한 데이터를 별도의 파일로 관리함

#### 파일 시스템의 문제점
> 1. 같은 내용의 데이터가 여러 파일에 중복 저장된다.
> 2. 응용 프로그램이 데이터 파일에 종속적이다.
> 3. 데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.
> 4. 응용 프로그램을 개발하기 쉽지 않다.

## DBMS (Database Management System)
 
- 파일 시스템의 문제를 해결하기 위해 제시된 소프트웨어

- 조직에 필요한 데이터를 데이터베이스에 통합하여 저장하고 관리함

#### DBMS 장점
> 1. 데이터 중복 통제
> 2. 데이터 독립성 확보
> 3. 데이터 동시 공유
> 4. 데이터 보안 향상
> 5. 데이터 무결성 유지
> 6. 표준화 가능
> 7. 장애 발생시 회복 가능
> 8. 응용 프로그램 개발 비용 감소

#### DBMS 단점
> 1. 비용이 많이듦
> 2. 백업과 회복 방법이 복잡
> 3. 중앙 집중 관리로 인한 취약점 존재

#### 파일시스템과 DBMS의 비교 표
| 구분           | 파일 시스템             | DBMS                    |
|--------------|--------------------|-------------------------|
| 데이터 정의       | 응용 프로그램            | DBMS                    |
| 데이터 저장       | 파일 시스템             | 데이터베이스                  |
| 데이터 접근 방법    | 응용 프로그램이 파일에 직접 접근 | 응용프로그램이 DBMS에 파일 접근 요청함 |
| 사용 언어        | 자바, C++, C 등       | 자바, C++, C 등과 SQL       |
| CPU/주기억장치 사용 | 적음                 | 많음                      |

[3]관계 데이터 모델의 개념
======================

## 릴레이션(relation)의 개념

- 논리적 데이터 모델
> 개념적 구조를 논리적 데이터 모델링하여 데이터베이스의 논리적구조로 표현하는 도구
 
- 수학의 집합이론에 근거함   

- 릴레이션(relation) -> 테이블로 이해하면 쉬움, ex Exel   
> 행과 열로 구성된 테이블을 말함   
> 하나의 개체를 하나의 릴레이션에 담음

- SQL 언어는 원하는 데이터를 쉽게 표현함   

- 관계 (relationship)
> 릴레이션(테이블) 내의 관계와 릴레이션(테이블) 간의 관계가 있음   
> 내의 관계 : 릴레이션 안에 있는 데이터들의 집합으로 표현함   
> 간의 관계 : 릴레이션을 식별 가능한 값을 이용해 표현함   
> ex. 도서 릴레이션의 '도서번호'와 고객 릴레이션의 '고객번호'를 주문 릴레이션에 저장하여 관계를 표현

## 릴레이션 스키마와 인스턴스
#### 릴레이션 (테이블)
- 스키마(schema)와 인스턴스(instance)로 이루어짐   

- 스키마(schema)
> 관계 데이터베이스의 릴레이션이 어떻게 구성되는지, 어떤 정보를 담고 있는지에 대한 기본적인 구조를 정의함

- 인스턴스(instance)
> 정의된 스키마에 따라 테이블에 실제로 저장되는 데이터 집합

- 도서 릴레이션
> 도서번호, 도서이름, 출판사, 가격은 릴레이션의 구조를 구성 => 스키마   
> 저장된 데이터 => 인스턴스

속성 (attribute) : 열   
도메인 (domain) : 속성이 가질 수 있는 값의 집함 (열별 데이터 타입)   
차수 (degree) : 속성의 개수   
투플 (tuple) : 행   
카디날리티 (cardinality) : 투플의 수   

- 투플은 중복되지 않아야함

[4] 릴레이션의 특징
=======

## 릴레이션의 특징
1. 속성은 단일 값을 가짐
> 각 속성의 값은 도메인에 정의된 값만 가지며 모두 단일

2. 속성은 서로 다른 이름을 가짐
> 한 릴레이션에서 서로 다른 값을 가짐

3. 한 송석의 값은 모두 같은 도메인 값을 가짐   
> 한 속성에 속한 열은 모두 그 속성에서 정의한 도메인 값만 가질 수 있음

4. 속성의 순서는 상관없음
> 속성의 순서가 달라도 릴레이션 스키마는 같음

5. 릴레이션 내의 중복된 투플은 허영하지 않음
> 하나의 릴레이션 인스턴스 내에서는 모든 투플은 서로 값이 달라야함

6. 투플의 순서는 상관 없음
> 투플의 순서가 달라도 같은 릴레이션임

## 관계 데이터 모델

- 데이터를 2차원 테이블 형태인 릴레이션으로 표현      
- 릴레이션에 대한 제약조건과 관계 연산을 위한 관계대수를 정의
> 제약조건 : 각 릴레이션에 저장된 데이터 갑이 가져야하는 제약   
> 관계대수 : 릴레이션을 다루는 연산 규칙

[5] 무결성 제약조건
===
## 키
- 한 대의 자동차는 반드시 한 개의 자동차 문을 열 수 있는 것 처럼 무엇인가를 유일하게 식별한다는 의미.      
- 관계 데이터베이스에서 키는 릴레이션에서 특정 투플을 식별할 때 사용하는 속성 혹은 속성의 집합.      
- 키가 되는 속성(혹은 속성의 집합)은 반드시 값이 달라서 투플들을 서로 구별할 수 있어야 함.      
- 릴레이션 간의 관계를 맺는 데도 사용됨.      
- 키의 종류 : 슈퍼키, 후보키, 기본키, 대리키, 대체키, 외래키

#### 수퍼키 (super key)
- 투플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합      
예)       

|고객번호   |이름   |주민번호   |주소   |핸드폰   |   
|----|----|----|----|----|
|1   |홍길동   |14430101-1111111   |전라도 장성현 아곡리 아치실 마을   |010-1234-1234   |

- 고객번호 : 고객별로 유일한 값이 부여되어 투플 식별 가능
- 이름 : 동명이인이 있으면 투플 식별 불가
- 주민번호 : 개인별로 유일한 값이 부여되어 투플 식별 가능
- 주소 : 가족끼리 동일하므로 투플 식별 불가
- 핸드폰 : 1인 다중 폰 또는 폰이 없는 사람 있어 투플 식별 불가      

- 고객 릴레이션의 수퍼키에는 투플 식별 가능한 '고객번호' 또는 '주민번호' 가 포함되야함.
수퍼키 ex. (고객번호), (고객번호, 이름), (고객번호, 이름, 주민번호)

#### 후보키 (candidate key)
- 투플을 유일하게 식별할 수 있는 속성의 최소 집합
- 수퍼키는 조합이 많지만, 후보키는 '주민번호', '고객번호'만 될 수 있음.
- 두 개 이상의 속성으로 이루어진 키를 복합키라고 함.
  (고객번호, 주민번호)

#### 기본키 (primary key)
- 여러 후보키 중 하나를 선정하여 대표로 삼는 키
- 기본키 선정시 고려사항
> 릴레이션 내 투플을 식별할 수 있는 고유한 값을 가져야함
> NULL 값은 허용하지 않음
> 키 값의 변동이 일어나지 않아야 함
> 최대한 적은 수의 속성을 가진 것이라야 함.
> 향후 키를 사용하는데 있어서 문제 발생 소지가 없어야 함

- 릴레이션 스키마를 표현할 떄 기본키는 다음과 같이 밑줄을 그어 표시           
> 릴레이션 이름 (속성1, 속성2, ..., 속성 N)      
> 고객(__고객번호__, 이름, 주민번호)


<u>밑줄 있는 텍스트입니다</u>      
<U>밑줄</U>

대리키
기본키가 보안을 필요로 하거나, 여러 개의 속성으로 구성되어 복잡하거나, 마땅한 기본키가 없을 때는 일련번호 같은 가상의 속성을 만들어 기본키로 삼는 경우
-> 가성의 속성 만들어 기본 키로 삼는 경우

대체키
기본키로 선정되지 않는 후보키 -> 고유한 값을 가져야함! 기본키처럼!
고객번호가 기본키가 되면, 주민번호가 대체키가 됨!

외래키
다른 릴레이션의 기본키를 참조하는 속성
참조하고 참조되는 양쪽 릴레이션의 도메인이 서로 같아야함! 도메인 = 데이터 타입

외래키 특징
관계 데이터 모델에서 릴레이션 간의 관계를 표현함
다른 릴레이션의 기본키를 참조하는 속성! 다른 테이블의 기본 열을 참조! 도메인 동일해야함
참조값 (기본키)가 변경되면 참조하는(외래키) 값도 변경됨
NULL과 중복값 허용됨
자기 자신의 기본키를 참조하는 외래키도 가능함
외래키는 기본키의 일부가 될 수 있음

## 무결성 제약조건

데이터 무결성
DB에 저장된 데이터의 일관성과 정확성을 지키는 것
일관성과 정확성을 바탕으로 구축된 DB가 계속해서 무결성을 유지하려면
튜플의 삽입 삭제 수정시 데이터 제약조건의 준수 여부를 확인해야함

도메인 무결성 제약조건
투플의 각 속성이 도메인에 지정된 값만 가져야함

개체 무결성 제약 조건 (기본기 제약)
기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야한다.
관계 데이터 모델의 핵심 개념

참조 무결성 제약조건 (외래키 제약)
참조 되는 릴레이션을 부모 릴레이션, 참조하는 릴레이션을 자식 릴레이션이라함
자식이 부모의 기본키와 도메인이 같아야함
자식값이 변경될 때 부모의 제약을 받음

## 무결성 제약조건의 수행


관계대수
 - 조인을 포함한 관계대수 사용을 보고 무엇을 검색하려는 것인지 파악하기   


공통 속성을 기준을 속성값이 투플을 수평으로 결합하는 연산
서로 동일한 도메인으로 구성되어야함   

기본조인   

세타조인
두 릴레이션간의 속성값을 비교하여 조건에 맞는 투플을 반환함
동등 조인
속성 값이 같은 투플만 반환함
자연조인
속성 이름이 같은 투플만 대상으로 하되 중복 속성을 제거하고 반환함




SQL 사용
 - create 구문
 - select 구문
  - 조인과 부속질의 
  - 부속질의는 select 부속질의 까지 범위
  - 시험 유형 검색문을 보고 작성하기 및 sql문을 보고 검색하여는 것인 무엇인지 파악하기



# Final exam

### 1. 뷰의 개념 및 뷰의 장단점      
- 개념      
  - 하나 이사의 테이블을 합하여 만든 가상의 테이블      
  - 최종 결과를 가상의 테이블로 정의하여 실제 테이블처럼 사용할 수 있도록 만든 개체
- 장점      
  - 편리성 - 자주 사용되는 단어를      
  - 보안성 - 사용자별로 필요한 데이터만 선별하여 시각화, 질의 내용 암호화 가능      
  - 독립성 - 원본 테이블의 구조가 변해도 응용에 영향을 주지 않도록 함
- 특징      
  - 원본 데이터 값에 따라 같이 변함      
  - 삽입, 삭제, 갱신 연산에 많은 제약이 따름
 
### 2. 판매가격이 20000원 이상인 도서의 도서번호, 도서이름, 고객이름, 출판사, 판매가격을 보여주는 highorders를 생성
#### 완전 두괄식 진행이라곤 느껴짐
CREATE VIEW 뷰이름 [(열이름[, ... n)]]      
AS SELECT 문      

create view highorders      
as select b.bookid, b.bookname c.name, b.publisher, o.saleprice      
from book b, orders o, customer c      
where b.bookid = o.bookid and o.custid = c.custid and saleprice >= 20000;      

create view highorders      
-- SELECT 문을 통해 원하는 데이터를 추출      
as select       
    &emsp;b.bookid,       -- 도서의 ID (도서번호)      
    &emsp;b.bookname,     -- 도서의 이름      
    &emsp;c.name,         -- 고객의 이름      
    &emsp;b.publisher,    -- 도서의 출판사      
    &emsp;o.saleprice     -- 판매 가격      
-- FROM 절에서는 여러 테이블을 사용. 각 테이블은 별칭을 사용하여 참조.      
from       
    &emsp;book b,         -- 도서 정보가 저장된 book 테이블, b라는 별칭 사용      
    &emsp;orders o,       -- 주문 정보가 저장된 orders 테이블, o라는 별칭 사용      
    &emsp;customer c      -- 고객 정보가 저장된 customer 테이블, c라는 별칭 사용      
-- WHERE 절은 조건을 지정.      
where       
    &emsp;b.bookid = o.bookid   -- book 테이블과 orders 테이블을 도서 ID(bookid)로 조인(join)      
    &emsp;and o.custid = c.custid -- orders 테이블과 customer 테이블을 고객 ID(custid)로 조인(join)      
    &emsp;and o.saleprice >= 20000; -- 조건: 판매가격(saleprice)이 20000원 이상인 경우    

### 3. highorders 뷰에서 판매가격 속성을 삭제하는 명령을 수행

create or replace view highorders      
as select b.bookid, b.bookname, c.name, b.publisher      
from book b, orders o, customer c      
where b.bookid = o.orders and o.custid = c.custid and saleprice >= 20000;      

-- 뷰(View)를 생성하거나, 기존 뷰를 대체하는 SQL 문.      
create or replace view highorders            
-- SELECT 문을 통해 필요한 데이터를 추출.      
as select       
    &emsp;b.bookid,       -- 도서의 ID (도서번호)      
    &emsp;b.bookname,     -- 도서의 이름      
    &emsp;c.name,         -- 고객의 이름      
    &emsp;b.publisher     -- 도서의 출판사      
-- FROM 절에서는 여러 테이블을 사용. 각 테이블은 별칭을 사용하여 참조.      
from       
    &emsp;book b,         -- 도서 정보가 저장된 book 테이블, b라는 별칭 사용      
    &emsp;orders o,       -- 주문 정보가 저장된 orders 테이블, o라는 별칭 사용      
    &emsp;customer c      -- 고객 정보가 저장된 customer 테이블, c라는 별칭 사용      
-- WHERE 절은 조건을 지정.      
where       
    &emsp;b.bookid = o.bookid   -- book 테이블과 orders 테이블을 도서 ID(bookid)로 조인(join)      
    &emsp;and o.custid = c.custid -- orders 테이블과 customer 테이블을 고객 ID(custid)로 조인(join)      
    &emsp;and o.saleprice >= 20000; -- 조건: 판매가격(saleprice)이 20000원 이상인 경우      

-- 위의 SELECT 문에서는 더 이상 판매가격(saleprice)을 선택하지 않으므로,       
-- 뷰에서 판매가격 속성이 삭제.      

### 4. 인덱스의 개념 및 특징

- Index(색인)
      - 데이터를 쉽고 빠르게 찾을 수 있도록 만든데이터 구조
      - 투플의 키 값에 대한 물리적 위치를 기록해둔 자료구조
- 장점
      - 검색 속도 향상 : 컬럼 값에 대한 레코드 위치 정보를 가짐
      - 정렬 및 순서 유지 : order vy 절의 성능 향상
        - 중복 제거 : unique 인덱스 사용
        - 조인 성능 향상 : 여러 테이블 간의 관계를 효율적으로 처리가능
        - 쿼리 성능 향상
- 단점
        -인덱스가 공간을 차지하여 추가적인 공간 필요, 약 10%
        - 처음 인덱스 생성하는데 시간소요
        - 데이터의 변경 작업(삽입, 삭제, 갱신)이 자주 일어나는 경우 성능 하락 가능성

### 5. 트리거에 대해서 설명

- 데이터의 변경문이 실행될 떄 자동으로 같이 실행되는 프리시저
- 트리거는 데이터의 변경이 실핼될 때 부수적으로 필요한 데이터의 기본값 제공, 데이터 제약 준수, SQL 뷰의 수정, 참조무결성 작업 등을 수행

### 6. ER모델의 표현 방법

ER모델      
데이터 모델링 과정 중 개념적 모델링에 사용하는 모델 - ER다이어그램 사용
![image](https://github.com/48hour/TIL/assets/105769305/e258b255-3487-460d-a91b-2e7c03ed6de8)

### 7. IE 표기법
![image](https://github.com/48hour/TIL/assets/105769305/7a2915b3-0c33-45d6-854e-3662938412b2)

### 8. 다음 ER 다이어그램을 테이블로 변환 (기본키 PK, 외래키 FK)
![image](https://github.com/48hour/TIL/assets/105769305/769f0155-f986-4751-a3b2-63536edac38c)


